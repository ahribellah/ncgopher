use config::{Config, File, FileFormat};
use serde::Serialize;
use std::fs::File as FsFile;
use std::io::Write;
use std::path::Path;

/// Manages server certificates for use in TOFU for the gemini protocol.
/// This could be modelled as a hashmap instead of a vector with structs,
/// but we might later extend the list with ip-address and cypher type.

#[derive(Clone, Debug, serde::Serialize)]
pub struct Certificate {
    pub host: String,
    pub fingerprint: String,
}

#[derive(Clone, Debug, Serialize)]
pub struct Certificates {
    /// All known server certificates
    pub entries: Vec<Certificate>,
}

impl Certificates {
    pub fn new() -> Certificates {
        let mut s = Config::new();
        let confdir = Certificates::get_known_hosts_filename();
        if Path::new(confdir.as_str()).exists() {
            match s.merge(File::new(confdir.as_str(), FileFormat::Toml)) {
                Ok(_s) => (),
                Err(e) => {
                    println!("Could not read known_hosts file: {}", e);
                }
            }
        }
        let mut entries = Vec::new();
        info!("certificates: {:?}", s.get_array("certificate"));
        if let Ok(e) = s.get_array("certificate") {
            for value in e {
                if let Ok(v) = value.into_table() {
                    let h = Certificate {
                        host: v["host"].clone().into_str().unwrap(),
                        fingerprint: v["fingerprint"].clone().into_str().unwrap(),
                    };
                    entries.push(h.clone());
                }
            }
        }
        Certificates { entries }
    }

    fn get_known_hosts_filename() -> String {
        let confdir: String = match dirs::config_dir() {
            Some(mut dir) => {
                dir.push(env!("CARGO_PKG_NAME"));
                dir.push("known_hosts");
                dir.into_os_string().into_string().unwrap()
            }
            None => String::new(),
        };
        info!("Looking for known_hosts file {}", confdir);
        confdir
    }

    // Checks if a certificate with a given url exists
    pub fn exists(&self, host: String) -> bool {
        self.entries.iter().any(|v| v.host == host)
    }

    pub fn add(&mut self, entry: Certificate) {
        info!("Adding entry to known_hosts: {:?}", entry);
        self.entries.push(entry);
        match self.write_known_hosts_to_file() {
            Err(why) => warn!("Could not write known_hosts to file: {}", why),
            Ok(()) => (),
        }
    }

    pub fn remove(&mut self, host: String) {
        info!("Removing entry from known_hosts: {:?}", host);
        self.entries.retain(|e| e.host != host);
        match self.write_known_hosts_to_file() {
            Err(why) => warn!("Could not write known_hosts file: {}", why),
            Ok(()) => (),
        }
    }

    pub fn fingerprint_by_host(&mut self, host: &str) -> Option<String> {
        info!("Looking for fingerprint for host {}", host);
        if let Some(pos) = self.entries.iter().position(|e| e.host == host) {
            return Some(self.entries[pos].fingerprint.clone());
        }
        None
    }

    pub fn write_known_hosts_to_file(&mut self) -> std::io::Result<()> {
        let filename = Certificates::get_known_hosts_filename();
        info!("Saving known_hosts to file: {}", filename);
        // Create a path to the desired file
        let path = Path::new(&filename);

        let mut file = match FsFile::create(&path) {
            Err(why) => return Err(why),
            Ok(file) => file,
        };

        if let Err(why) = file.write(b"# Automatically generated by ncgopher.\n") {
            return Err(why);
        };
        for b in self.clone().entries {
            if let Err(why) = file.write(b"\n[[certificate]]\n") {
                return Err(why);
            };
            let item = toml::to_string(&b).unwrap();
            if let Err(why) = file.write_all(item.as_bytes()) {
                return Err(why);
            };
        }
        Ok(())
    }
}
